//
//  This CSharp output file generated by Gardens Point LEX
//  Version:  1.0.1.250 (2009-01-01)
//  Machine:  BISCUITCOOKIE
//  DateTime: 05-Dec-19 18:24:06
//  UserName: Ruslani
//  GPLEX input file <Imperative.lex>
//  GPLEX frame file <gplexx.frame>
//
//  Option settings: parser, stack, minimize, compressnext
//

//
// gplexx.frame
// Version 1.0.0 of 01-November-2008
//

#define BACKUP
#define STACK
#define BYTEMODE

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

#if !STANDALONE

#endif

namespace CompilersProject.Compiler.Lexer {
	/// <summary>
	///     Summary Canonical example of GPLEX automaton
	/// </summary>
#if STANDALONE
    //
    // These are the dummy declarations for stand-alone GPLEX applications
    // normally these declarations would come from the parser.
    // If you declare /noparser, or %option noparser then you get this.
    //

    public enum Tokens
    { 
      EOF = 0, maxParseToken = int.MaxValue 
      // must have at least these two, values are almost arbitrary
    }

    public abstract class ScanBase
    {
        public abstract int yylex();
        protected virtual bool yywrap() { return true; }
#if BABEL
        protected abstract int CurrentSc { get; set; }
        // EolState is the 32-bit of state data persisted at 
        // the end of each line for Visual Studio colorization.  
        // The default is to return CurrentSc.  You must override
        // this if you want more complicated behavior.
        public virtual int EolState { 
            get { return CurrentSc; }
            set { CurrentSc = value; } 
        }
    }
    
    public interface IColorScan
    {
        void SetSource(string source, int offset);
        int GetNext(ref int state, out int start, out int end);
#endif // BABEL
    }
#endif // STANDALONE
	public abstract class ScanBuff {
		public const int EOF = -1;
		public abstract int Pos { get; set; }
		public abstract int Read();
		public abstract int Peek();
		public abstract int ReadPos { get; }
		public abstract string GetString(int b, int e);

		public const int UnicodeReplacementChar = 0xFFFD;
	}

	// If the compiler can't find ScanBase maybe you need to run
	// GPPG with the /gplex option, or GPLEX with /noparser
#if BABEL
    public sealed partial class Scanner : ScanBase, IColorScan
    {
        public ScanBuff buffer;
        int currentScOrd = 0;  // start condition ordinal
        
        protected override int CurrentSc 
        {
             // The current start state is a property
             // to try to avoid the user error of setting
             // scState but forgetting to update the FSA
             // start state "currentStart"
             //
             get { return currentScOrd; }  // i.e. return YY_START;
             set { currentScOrd = value;   // i.e. BEGIN(value);
                   currentStart = startState[value]; }
        }
#else // BABEL
	public sealed class Scanner : ScanBase {
		public ScanBuff buffer;
		private int currentScOrd; // start condition ordinal
#endif // BABEL

		private static int GetMaxParseToken() {
			var f = typeof(Tokens).GetField("maxParseToken");
			return f == null ? int.MaxValue : (int) f.GetValue(null);
		}

		private static readonly int parserMax = GetMaxParseToken();

		private enum Result { accept, noMatch, contextFound }

		private const int maxAccept = 112;
		private const int initial = 1;
		private const int eofNum = 0;
		private const int goStart = -1;
		private const int INITIAL = 0;

		#region user code

		#endregion user code

		private int state;
		private int currentStart = startState[0];
		private int chr; // last character read
		private int cNum; // ordinal number of chr
		private int lNum; // current line number

		private int lineStartNum; // ordinal number at start of line

		//
		// The following instance variables are used, among other
		// things, for constructing the yylloc location objects.
		//
		private int tokNum; // ordinal number of first character
		private int tokEPos; // buffer position at end of token
		private int tokECol; // column number at end of token
		private int tokELin; // line number at end of token
		private string tokTxt; // lazily constructed text of token
#if STACK
		private readonly Stack<int> scStack = new Stack<int>();
#endif // STACK

		#region ScannerTables

		private struct Table {
			public readonly int min;
			public readonly int rng;
			public readonly int dflt;
			public readonly sbyte[] nxt;

			public Table(int m, int x, int d, sbyte[] n) {
				min = m;
				rng = x;
				dflt = d;
				nxt = n;
			}
		}

		private static readonly int[] startState = {1, 0};

		private static readonly Table[] NxS = new Table[116];

		static Scanner() {
			NxS[0] = new Table(0, 0, 0, null);
			NxS[1] = new Table(9, 117, -1, new sbyte[] {
				2, 3, -1, -1, -1, -1,
				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
				-1, 2, -1, -1, -1, -1, 4, -1, 113, 5, 6, 7, 8, 9, 10, 11,
				12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 15, 16, 17, 18,
				-1, -1, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, -1, 21, -1,
				-1, -1, 22, 23, 19, 19, 24, 25, 19, 19, 26, 19, 19, 27, 19, 19,
				28, 19, 19, 29, 19, 30, 19, 31, 32, 33, 19, 19, 34, -1, 35
			});
			NxS[2] = new Table(9, 24, -1, new sbyte[] {
				2, -1, -1, -1, -1, -1,
				-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
				-1, 2
			});
			NxS[3] = new Table(10, 1, -1, new sbyte[] {3});
			NxS[4] = new Table(0, 0, -1, null);
			NxS[5] = new Table(0, 0, -1, null);
			NxS[6] = new Table(0, 0, -1, null);
			NxS[7] = new Table(0, 0, -1, null);
			NxS[8] = new Table(0, 0, -1, null);
			NxS[9] = new Table(0, 0, -1, null);
			NxS[10] = new Table(48, 10, -1, new sbyte[] {
				13, 13, 13, 13, 13, 13,
				13, 13, 13, 13
			});
			NxS[11] = new Table(46, 1, -1, new sbyte[] {111});
			NxS[12] = new Table(61, 1, -1, new sbyte[] {110});
			NxS[13] = new Table(46, 12, -1, new sbyte[] {
				114, -1, 13, 13, 13, 13,
				13, 13, 13, 13, 13, 13
			});
			NxS[14] = new Table(61, 1, -1, new sbyte[] {108});
			NxS[15] = new Table(0, 0, -1, null);
			NxS[16] = new Table(61, 1, -1, new sbyte[] {107});
			NxS[17] = new Table(0, 0, -1, null);
			NxS[18] = new Table(61, 1, -1, new sbyte[] {106});
			NxS[19] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[20] = new Table(0, 0, -1, null);
			NxS[21] = new Table(0, 0, -1, null);
			NxS[22] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 100, 19, 19, 19, 101, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[23] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 94, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[24] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 89, 19, 90, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[25] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 83, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 84, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[26] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				75, 19, 19, 19, 19, 19, 19, 19, 76, 19, 19, 19, 19, 77, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[27] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 72, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[28] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 71, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[29] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 53,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 54, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[30] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 44, 19, 19, 19, 19, 19, 19, 19, 19, 19, 45, 19, 19, 19,
				19, 19, 19, 46, 19
			});
			NxS[31] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 42, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[32] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 38, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[33] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 36, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[34] = new Table(0, 0, -1, null);
			NxS[35] = new Table(0, 0, -1, null);
			NxS[36] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 37, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[37] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[38] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 39, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[39] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 40, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[40] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 41,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[41] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[42] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 43, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[43] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[44] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 51,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[45] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 49,
				19, 19, 19, 19, 19
			});
			NxS[46] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 47, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[47] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 48,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[48] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[49] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 50,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[50] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[51] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 52, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[52] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[53] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 60, 19, 61, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				62, 19, 19, 19, 19
			});
			NxS[54] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 55,
				19, 19, 19, 19, 19
			});
			NxS[55] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 56, 19,
				19, 19, 19, 19, 19
			});
			NxS[56] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 57, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[57] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 58, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[58] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 59,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[59] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[60] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 70, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[61] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 67, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[62] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 63,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[63] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 64, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[64] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 65, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[65] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 66,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[66] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[67] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 68, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[68] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 69, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[69] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[70] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[71] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[72] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 73, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[73] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 74, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[74] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[75] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[76] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 78, 19,
				19, 19, 19, 19, 19
			});
			NxS[77] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[78] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 79,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[79] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 80, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[80] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 81,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[81] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 82, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[82] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[83] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 86, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[84] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 85, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[85] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[86] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 87, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[87] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 88,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[88] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[89] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 92, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[90] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 91, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[91] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[92] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 93,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[93] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[94] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 95, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[95] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 96, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[96] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 97,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[97] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 98, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[98] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 99, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[99] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[100] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 105, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[101] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 102, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[102] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 103, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[103] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 104, 19
			});
			NxS[104] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[105] = new Table(48, 75, -1, new sbyte[] {
				19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, -1, -1, -1, -1, -1, -1, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, -1, -1, -1, -1, 19, -1, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
				19, 19, 19, 19, 19
			});
			NxS[106] = new Table(0, 0, -1, null);
			NxS[107] = new Table(0, 0, -1, null);
			NxS[108] = new Table(0, 0, -1, null);
			NxS[109] = new Table(48, 10, -1, new sbyte[] {
				109, 109, 109, 109, 109, 109,
				109, 109, 109, 109
			});
			NxS[110] = new Table(0, 0, -1, null);
			NxS[111] = new Table(0, 0, -1, null);
			NxS[112] = new Table(0, 0, -1, null);
			NxS[113] = new Table(0, 1, -1, new sbyte[] {115});
			NxS[114] = new Table(48, 10, -1, new sbyte[] {
				109, 109, 109, 109, 109, 109,
				109, 109, 109, 109
			});
			NxS[115] = new Table(39, 1, -1, new sbyte[] {112});
		}

		private int NextState(int qStat) {
			if (chr == ScanBuff.EOF) return eofNum;

			int rslt;
			int idx = (byte) (chr - NxS[qStat].min);
			if ((uint) idx >= (uint) NxS[qStat].rng) rslt = NxS[qStat].dflt;
			else rslt = NxS[qStat].nxt[idx];
			return rslt;
		}

		private int NextState() {
			if (chr == ScanBuff.EOF) return eofNum;

			int rslt;
			int idx = (byte) (chr - NxS[state].min);
			if ((uint) idx >= (uint) NxS[state].rng) rslt = NxS[state].dflt;
			else rslt = NxS[state].nxt[idx];
			return rslt;
		}

// EXPERIMENTAL: This is the NextState method that
// is used by the CharClassPredicate functions for V0.9
		private int TestNextState(int qStat, int chr) {
			if (chr == ScanBuff.EOF) return eofNum;

			int rslt;
			int idx = (byte) (chr - NxS[qStat].min);
			if ((uint) idx >= (uint) NxS[qStat].rng) rslt = NxS[qStat].dflt;
			else rslt = NxS[qStat].nxt[idx];
			return rslt;
		}

		#endregion


#if BACKUP
		// ==============================================================
		// == Nested class used for backup in automata which do backup ==
		// ==============================================================

		internal class Context // class used for automaton backup.
		{
			public int bPos;
			public int cChr;
			public int cNum;
			public int lNum; // Need this in case of backup over EOL.
			public int state;
		}
#endif // BACKUP

		// ==============================================================
		// ==== Nested struct to support input switching in scanners ====
		// ==============================================================

		private struct BufferContext {
			internal ScanBuff buffSv;
			internal int chrSv;
			internal int cNumSv;
			internal int lNumSv;
			internal int startSv;
		}

		#region Buffer classes

		// ==============================================================
		// ===== Private methods to save and restore buffer contexts ====
		// ==============================================================

		/// <summary>
		///     This method creates a buffer context record from
		///     the current buffer object, together with some
		///     scanner state values.
		/// </summary>
		private BufferContext MkBuffCtx() {
			BufferContext rslt;
			rslt.buffSv = buffer;
			rslt.chrSv = chr;
			rslt.cNumSv = cNum;
			rslt.lNumSv = lNum;
			rslt.startSv = lineStartNum;
			return rslt;
		}

		/// <summary>
		///     This method restores the buffer value and allied
		///     scanner state from the given context record value.
		/// </summary>
		private void RestoreBuffCtx(BufferContext value) {
			buffer = value.buffSv;
			chr = value.chrSv;
			cNum = value.cNumSv;
			lNum = value.lNumSv;
			lineStartNum = value.startSv;
		}

		// ==============================================================
		// ===== Nested classes for various ScanBuff derived classes ====
		// ==============================================================
		// =============== Nested class for string input ================
		// ==============================================================

		/// <summary>
		///     This class read characters from a single string as
		///     required, for example, by Visual Studio language services
		/// </summary>
		public sealed class StringBuff : ScanBuff {
			private readonly int sLen;
			private readonly string str; // input buffer

			public StringBuff(string str) {
				this.str = str;
				sLen = str.Length;
			}

			public override int ReadPos => Pos - 1;

			public override int Pos { get; set; }

			private int Read16() {
				if (Pos < sLen)
					return str[Pos++];
#if BABEL
                else if (bPos == sLen) { bPos++; return '\n'; }   // one strike, see newline
#endif // BABEL

				Pos++;
				return EOF;
			}

			/// <summary>
			///     Read returns UTF32 in this application.
			/// </summary>
			/// <returns>Unicode point as an int [0 .. 0xFFFFF]; -1 for EOF</returns>
			public override int Read() {
				var utf16 = Read16();
				if (utf16 < 0xD800 || utf16 > 0xDBFF) return utf16;

				var low16 = Read16();
				if (low16 < 0xDC00 || low16 > 0xDFFF)
					return UnicodeReplacementChar;
				return 0x10000 + (utf16 & (0x3FF << 10)) + (low16 & 0x3FF);
			}

			public override int Peek() {
				if (Pos < sLen) return str[Pos];
				return '\n';
			}

			public override string GetString(int beg, int end) {
				//  "end" can be greater than sLen with the BABEL
				//  option set.  Read returns a "virtual" EOL if
				//  an attempt is made to read past the end of the
				//  string buffer.  Without the guard any attempt 
				//  to fetch yytext for a token that includes the 
				//  EOL will throw an index exception.
				if (end > sLen) end = sLen;
				if (end <= beg) return "";
				return str.Substring(beg, end - beg);
			}
		}

#if !NOFILES
		// ====================== Nested class ==========================
		//  The LineBuff class contributed by Nigel Horspool, 
		//  nigelh@cs.uvic.cs
		// ==============================================================

		public sealed class LineBuff : ScanBuff {
			private readonly IList<string> line; // list of source lines from a file
			private readonly int numLines; // number of strings in line list
			private int cachedIx;
			private int cachedLstart;

			// To speed up searches for the line containing a position
			private int cachedPos;
			private int cLine; // index of current line in the list
			private int cPos; // ordinal number of chr in source
			private int curLen; // length of current line
			private string curLine; // current line in that list
			private int curLineEnd; // position of line end in whole file
			private int curLineStart; // position of line start in whole file
			private int maxPos; // max position ever visited in whole file

			// Constructed from a list of strings, one per source line.
			// The lines have had trailing '\n' characters removed.
			public LineBuff(IList<string> lineList) {
				line = lineList;
				numLines = line.Count;
				cPos = curLineStart = 0;
				curLine = numLines > 0 ? line[0] : "";
				maxPos = curLineEnd = curLen = curLine.Length;
				cLine = 1;
			}

			public override int Pos {
				get => cPos;
				set {
					cPos = value;
					findIndex(cPos, out cLine, out curLineStart);
					curLine = line[cLine];
					curLineEnd = curLineStart + curLine.Length;
				}
			}

			public override int ReadPos => cPos - 1;

			public override int Read() {
				if (cPos < curLineEnd)
					return curLine[cPos++ - curLineStart];
				if (cPos++ == curLineEnd)
					return '\n';
				if (cLine >= numLines)
					return EOF;
				curLine = line[cLine];
				curLen = curLine.Length;
				curLineStart = curLineEnd + 1;
				curLineEnd = curLineStart + curLen;
				if (curLineEnd > maxPos)
					maxPos = curLineEnd;
				cLine++;
				return curLen > 0 ? curLine[0] : '\n';
			}

			public override int Peek() {
				return cPos < curLineEnd ? curLine[cPos - curLineStart] : '\n';
			}

			// Given a position pos within the entire source, the results are
			//   ix     -- the index of the containing line
			//   lstart -- the position of the first character on that line
			private void findIndex(int pos, out int ix, out int lstart) {
				if (pos >= cachedPos) {
					ix = cachedIx;
					lstart = cachedLstart;
				} else {
					ix = lstart = 0;
				}

				for (;;) {
					var len = line[ix].Length + 1;
					if (pos < lstart + len) break;
					lstart += len;
					ix++;
				}

				cachedPos = pos;
				cachedIx = ix;
				cachedLstart = lstart;
			}

			public override string GetString(int beg, int end) {
				if (beg >= maxPos || end <= beg) return "";
				int endIx, begIx, endLineStart, begLineStart;
				findIndex(beg, out begIx, out begLineStart);
				var begCol = beg - begLineStart;
				findIndex(end, out endIx, out endLineStart);
				var endCol = end - endLineStart;
				var s = line[begIx];
				if (begIx == endIx) // the usual case, substring all on one line
					return endCol <= s.Length
						? s.Substring(begCol, endCol - begCol)
						: s.Substring(begCol) + "\n";
				// the string spans multiple lines, yuk!
				var sb = new StringBuilder();
				if (begCol < s.Length)
					sb.Append(s.Substring(begCol));
				for (;;) {
					sb.Append("\n");
					s = line[++begIx];
					if (begIx >= endIx) break;
					sb.Append(s);
				}

				if (endCol <= s.Length) {
					sb.Append(s.Substring(0, endCol));
				} else {
					sb.Append(s);
					sb.Append("\n");
				}

				return sb.ToString();
			}
		}

		// ==============================================================
		// =========== Nested class StreamBuff : byte files =============
		// ==============================================================

		/// <summary>
		///     This is the Buffer for byte files. It returns 8-bit characters.
		/// </summary>
		public class StreamBuff : ScanBuff {
			protected BufferedStream bStrm; // input buffer
			protected int delta = 1; // number of bytes in chr, could be 0 for EOF.

			public StreamBuff(Stream str) {
				bStrm = new BufferedStream(str);
			}

			public override int ReadPos => (int) bStrm.Position - delta;

			// Pos is the position *after* reading chr!
			public override int Pos {
				get => (int) bStrm.Position;
				set => bStrm.Position = value;
			}

			/// <summary>
			///     Read returns subset [0 .. 0xFF] in this application.
			/// </summary>
			/// <returns>Unicode point as an int [0 .. 0xFF]; -1 for EOF</returns>
			public override int Read() {
				var ch0 = bStrm.ReadByte();
				delta = ch0 == EOF ? 0 : 1;
				return ch0;
			}

			public override int Peek() {
				var rslt = bStrm.ReadByte();
				bStrm.Seek(-delta, SeekOrigin.Current);
				return rslt;
			}

			public override string GetString(int beg, int end) {
				if (end - beg <= 0) return "";
				var savePos = bStrm.Position;
				var arr = new char[end - beg];
				bStrm.Position = beg;
				for (var i = 0; i < end - beg; i++)
					arr[i] = (char) bStrm.ReadByte();
				bStrm.Position = savePos;
				return new string(arr);
			}

			public static int GetCodePage(string command) {
				command = command.ToLower();
				if (command.StartsWith("codepage:"))
					command = command.Substring(9);
				try {
					if (command.Equals("raw")) return -1;

					if (command.Equals("guess")) return -2;

					if (command.Equals("default")) return 0;

					if (char.IsDigit(command[0])) {
						return int.Parse(command);
					}

					var enc = Encoding.GetEncoding(command);
					return enc.CodePage;
				} catch {
					Console.Error.WriteLine(
						"Unknown codepage \"{0}\", using machine default", command);
					return 0;
				}
			}
		}

#if !BYTEMODE
        // ==============================================================
        // ===== Nested class CodePageBuff : for unicode text files =====
        // ========= Byte files mapped by a specified CodePage ==========
        // ==============================================================

        public sealed class CodePageBuff : StreamBuff
        {
        
            char[] map = new char[256];
            
            public CodePageBuff(Stream stream) : this(stream, Encoding.Default) { }

            
            public CodePageBuff(Stream stream, Encoding enc) : base(stream)
            {
                bool done;
                int bNum, cNum;
                byte[] bArray = new byte[256];
                if (!enc.IsSingleByte)
                    throw new NotImplementedException(
                        "Only UTF-8, UTF-16 and single-byte code pages allowed");
                Decoder decoder = enc.GetDecoder();
                for (int i = 0; i < 256; i++)
                    bArray[i] = (byte)i;
                decoder.Convert(bArray, 0, 256, this.map, 0, 256, true, out bNum, out cNum, out done);
            }
            
            /// <summary>
            /// Read returns subset unicode char corresponding to the
            /// given character in the chosen codepage.
            /// </summary>
            /// <returns>Unicode point as an int; -1 for EOF</returns>
            public override int Read() {
                int ch0 = bStrm.ReadByte();
                if (ch0 == EOF)
                {
                    delta = 0; return -1;
                }
                else
                {
                    delta = 1; return this.map[ch0];
                } 
            }
            
            public override string GetString(int beg, int end)
            {
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                int saveDelta = delta;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                for (int i = 0; i < (end - beg); i++)
                    arr[i] = (char)Read();
                bStrm.Position = savePos;
                delta = saveDelta;
                return new String(arr);
            }
        }
        

        // ==============================================================
        // ====== Nested class TextBuff : for unicode text files ========
        // ==== This is the UTF8 class, UTF16 handled by subclasses =====
        // ==============================================================

        /// <summary>
        /// This is the Buffer for UTF8 files.
        /// It attempts to read the encoding preamble, which for 
        /// this encoding should be unicode point \uFEFF which is 
        /// encoded as EF BB BF
        /// </summary>
        public class TextBuff : ScanBuff
        {
            protected BufferedStream bStrm;   // input buffer
            protected int delta = 1;          // length of chr, zero for EOF!
            

            /// <summary>
            /// TextBuff factory.  Reads the file preamble
            /// and returns a TextBuff, LittleEndTextBuff or
            /// BigEndTextBuff according to the result.
            /// </summary>
            /// <param name="strm">The underlying stream</param>
            /// <returns></returns>
            public static ScanBuff NewTextBuff(Stream strm, int fallbackCodepage)
            {
                // First check if this is a UTF16 file
                //
                int b0 = strm.ReadByte();
                int b1 = strm.ReadByte();

                if (b0 == 0xfe && b1 == 0xff)
                    return new BigEndTextBuff(strm);
                if (b0 == 0xff && b1 == 0xfe)
                    return new LittleEndTextBuff(strm);
                
                int b2 = strm.ReadByte();
                if (b0 == 0xef && b1 == 0xbb && b2 == 0xbf)
                    return new TextBuff(strm);
                //
                // There is no unicode preamble, so
                // we go back to the bytefile default.
                //
                strm.Seek(0, SeekOrigin.Begin);
                
                switch (fallbackCodepage)
                {
                    case -2:
                        {
                            int guess = new Guesser.Scanner(strm).GuessCodepage();
                            strm.Seek(0, SeekOrigin.Begin);
                            if (guess == 0)
                                return new CodePageBuff(strm);
                            else if (guess == 65001)
                                return new TextBuff(strm);
                            else
                                return new StreamBuff(strm);
                        }                        
                    case -1:
                        return new StreamBuff(strm);
                    case 0:
                        return new CodePageBuff(strm); // Default codepage
                    case 65001:
                        return new TextBuff(strm);
                    case 1200:
                        return new LittleEndTextBuff(strm);
                    case 1201:
                        return new BigEndTextBuff(strm);
                    default:
                        return new CodePageBuff(strm, Encoding.GetEncoding(fallbackCodepage));
                }
            }

            protected TextBuff(Stream str) { 
                this.bStrm = new BufferedStream(str);
            }

            /// <summary>
            /// Read returns UTF32 in this application.
            /// </summary>
            /// <returns>Unicode point as an int [0 .. 0xFFFFF]; -1 for EOF</returns>
            public override int Read()
            {
                int ch0 = bStrm.ReadByte();
                int ch1, ch2, ch3,ch4, ch5;
                int result = UnicodeReplacementChar;

                if (ch0 < 0x7f)
                {
                    delta = (ch0 == EOF ? 0 : 1);
                    result = ch0;
                }
                else if ((ch0 & 0xe0) == 0xc0)
                {
                    delta = 2;
                    ch1 = bStrm.ReadByte();
                    if ((ch1 & 0xc0) == 0x80)
                        result = ((ch0 & 0x1f) << 6) + (ch1 & 0x3f);
                }
                else if ((ch0 & 0xf0) == 0xe0)
                {
                    delta = 3;
                    ch1 = bStrm.ReadByte(); ch2 = bStrm.ReadByte();
                    if ((ch1 & 0xc0) == 0x80 && (ch2 & 0xc0) == 0x80)
                        result = ((ch0 & 0xf) << 12) + ((ch1 & 0x3f) << 6) + (ch2 & 0x3f);
                }
                else if ((ch0 & 0xf8) == 0xf0)
                {
                    delta = 4;
                    ch1 = bStrm.ReadByte(); ch2 = bStrm.ReadByte(); ch3 = bStrm.ReadByte();
                    if ((ch1 & 0xc0) == 0x80 && (ch2 & 0xc0) == 0x80 && (ch3 & 0xc0) == 0x80)
                    {
                        result = ((ch0 & 0x7) << 18) + ((ch1 & 0x3f) << 12) + 
                                 ((ch2 & 0x3f) << 6) + (ch3 & 0x3f);
                    }
                }
                else if ((ch0 & 0xfc) == 0xf8)
                {
                    delta = 5;
                    ch1 = bStrm.ReadByte(); ch2 = bStrm.ReadByte();
                    ch3 = bStrm.ReadByte(); ch4 = bStrm.ReadByte();
                    if ((ch1 & 0xc0) == 0x80 && (ch2 & 0xc0) == 0x80 && (ch3 & 0xc0) == 0x80 && (ch4 & 0xc0) == 0x80)
                    {
                        result = ((ch0 & 0x3) << 24) + ((ch1 & 0x3f) << 18) + 
                                     ((ch2 & 0x3f) << 12) + ((ch3 & 0x3f) << 6) + (ch4 & 0x3f);
                    }
                }
                else if ((ch0 & 0xfe) == 0xfc)
                {
                    delta = 6;
                    ch1 = bStrm.ReadByte(); ch2 = bStrm.ReadByte(); ch3 = bStrm.ReadByte();
                    ch4 = bStrm.ReadByte(); ch5 = bStrm.ReadByte();

                    if ((ch1 & 0xc0) == 0x80 && (ch2 & 0xc0) == 0x80 && 
                        (ch3 & 0xc0) == 0x80 && (ch4 & 0xc0) == 0x80 && (ch5 & 0xc0) == 0x80)
                    {
                        result = ((ch0 & 0x1) << 28) + ((ch1 & 0x3f) << 24) + ((ch2 & 0x3f) << 18) + 
                                     ((ch3 & 0x3f) << 12) + ((ch4 & 0x3f) << 6) + (ch5 & 0x3f);
                    }
                }
                return result;
            }

            public sealed override int ReadPos
            {
                get { return (int)bStrm.Position - delta; }
            }

            public sealed override int Peek()
            {
                int rslt = Read();
                bStrm.Seek(-delta, SeekOrigin.Current);
                return rslt;
            }

            /// <summary>
            /// Returns the string from the buffer between
            /// the given file positions.  This needs to be
            /// done carefully, as the number of characters
            /// is, in general, not equal to (end - beg).
            /// </summary>
            /// <param name="beg">Begin filepos</param>
            /// <param name="end">End filepos</param>
            /// <returns></returns>
            public override string GetString(int beg, int end)
            {
                int i;
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                int saveDelta = delta;
                //
                //  The length of the array cannot be larger than
                //  end - beg, since if the characters expand by 
                //  using surrogate pairs the UTF8 must have taken
                //  up at least four bytes for any such character.
                //
                char[] arr = new char[end - beg];
                
                bStrm.Position = (long)beg;
                // Normally each call of Read() returns a valid UTF16
                // value which will take up one place in the string.
                // However, if read returns a value > 0xFFFF then a
                // *pair* of surrogate characters must be added.
                for (i = 0; bStrm.Position < end; i++)
                {
                    int value = Read();
                    if (value < 0xFFFF)
                        arr[i] = (char)value;
                    else
                    {
                        int temp = value - 0x10000;
                        arr[i++] = (char)(0xD800 + temp / 1024);
                        arr[i] = (char)(0xDC00 + temp % 1024);
                    }
                }
                bStrm.Position = savePos;
                delta = saveDelta;
                return new String(arr, 0, i);
            }

            // Pos is the position *after* reading chr!
            public sealed override int Pos
            {
                get { return (int)bStrm.Position; }
                set { bStrm.Position = value; }
            }
        }
        
        // ==============================================================
        // ====================== Nested class ==========================
        // ==============================================================
        
        /// <summary>
        /// This is the Buffer for Big-endian UTF16 files.
        /// </summary>
        public sealed class BigEndTextBuff : TextBuff
        {
            internal BigEndTextBuff(Stream str) : base(str) { } // 

            private int Read16()
            {
                int ch0 = bStrm.ReadByte();
                int ch1 = bStrm.ReadByte();
                if (ch1 == EOF)
                {
                    // An EOF in either byte counts as an EOF
                    delta = (ch0 == EOF ? 0 : 1);
                    return -1;
                }
                else
                {
                    delta = 2;
                    return (ch0 << 8) + ch1;
                }
            }
            
            /// <summary>
            /// Read returns UTF32 in this application.
            /// </summary>
            /// <returns>Unicode point as an int [0 .. 0xFFFFF]; -1 for EOF</returns>
            public override int Read()
            {
                int utf16 = Read16();
                if (utf16 < 0xD800 || utf16 > 0xDBFF)
                    return utf16;
                else
                {
                    int low16 = Read16();
                    delta = 4;
                    if (low16 < 0xDC00 || low16 > 0xDFFF)
                        return UnicodeReplacementChar;
                    else
                        return (0x10000 + (utf16 & 0x3FF << 10) + (low16 & 0x3FF));
                }
            }
            
            /// <summary>
            /// Returns the string from the buffer between
            /// the given file positions.  This needs to be
            /// done carefully, as the number of characters
            /// is, in general, not equal to (end - beg).
            /// </summary>
            /// <param name="beg">Begin filepos</param>
            /// <param name="end">End filepos</param>
            /// <returns></returns>
            public sealed override string GetString(int beg, int end)
            {
                int i;
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                int saveDelta = delta;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                // This stream will have utf16 valid for strings
                for (i = 0; bStrm.Position < end; i++)
                    arr[i] = (char)Read();
                bStrm.Position = savePos;
                delta = saveDelta;
                return new String(arr, 0, i);
            }
        }

        // ==============================================================
        // ====================== Nested class ==========================
        // ==============================================================
        
        /// <summary>
        /// This is the Buffer for Little-endian UTF16 files.
        /// </summary>
        public sealed class LittleEndTextBuff : TextBuff
        {
            internal LittleEndTextBuff(Stream str) : base(str) { } // { this.bStrm = new BufferedStream(str); }

            private int Read16()
            {
                int ch0 = bStrm.ReadByte();
                int ch1 = bStrm.ReadByte();
                if (ch1 == EOF)
                {
                    // An EOF in either byte counts as an EOF
                    delta = (ch0 == EOF ? 0 : 1);
                    return -1;
                }
                else
                {
                    delta = 2;
                    return (ch1 << 8) + ch0;
                }
            }
            
            /// <summary>
            /// Read returns UTF32 in this application.
            /// </summary>
            /// <returns>Unicode point as an int [0 .. 0xFFFFF]; -1 for EOF</returns>
            public override int Read()
            {
                int utf16 = Read16();
                if (utf16 < 0xD800 || utf16 > 0xDBFF)
                    return utf16;
                else
                {
                    int low16 = Read16();
                    delta = 4;
                    if (low16 < 0xDC00 || low16 > 0xDFFF)
                        return UnicodeReplacementChar;
                    else
                        return (0x10000 + (utf16 & 0x3FF << 10) + (low16 & 0x3FF));
                }
            }
            
            /// <summary>
            /// Returns the string from the buffer between
            /// the given file positions.  This needs to be
            /// done carefully, as the number of characters
            /// is, in general, not equal to (end - beg).
            /// </summary>
            /// <param name="beg">Begin filepos</param>
            /// <param name="end">End filepos</param>
            /// <returns></returns>
            public sealed override string GetString(int beg, int end)
            {
                int i;
                if (end - beg <= 0) return "";
                long savePos = bStrm.Position;
                int saveDelta = delta;
                char[] arr = new char[end - beg];
                bStrm.Position = (long)beg;
                // This stream will have utf16 valid for strings
                for (i = 0; bStrm.Position < end; i++)
                    arr[i] = (char)Read16();
                bStrm.Position = savePos;
                delta = saveDelta;
                return new String(arr, 0, i);
            }
        }
#endif // !BYTEMODE
#endif // !NOFILES

		#endregion Buffer classes

		// =================== End Nested classes =======================

#if !NOFILES
		public Scanner(Stream file) {
			SetSource(file); // no unicode option
		}

		public Scanner(Stream file, string codepage) {
			SetSource(file); // Not unicode, ignoring codepage
		}

#endif // !NOFILES

		public Scanner() {
		}

		private void GetChr() {
			if (chr == '\n') // This needs to be fixed for other conventions
			{
				lineStartNum = cNum + 1;
				lNum++;
			}

			chr = buffer.Read();
			cNum++;
		}

		private void MarkToken() {
			yypos = buffer.ReadPos;
			tokNum = cNum;
			yyline = lNum;
			yycol = cNum - lineStartNum;
		}

		private void MarkEnd() {
			tokTxt = null;
			yyleng = cNum - tokNum;
			tokEPos = buffer.ReadPos;
			tokELin = lNum;
			tokECol = cNum - lineStartNum;
		}

		// ==============================================================
		// =====    Initialization of string-based input buffers     ====
		// ==============================================================

		/// <summary>
		///     Create and initialize a StringBuff buffer object for this scanner
		/// </summary>
		/// <param name="source">the input string</param>
		/// <param name="offset">starting offset in the string</param>
		public void SetSource(string source, int offset) {
			buffer = new StringBuff(source);
			buffer.Pos = offset;
			lNum = 0;
			cNum = offset - 1;
			chr = '\n'; // to initialize yyline, yycol and lineStart
			GetChr();
		}

#if !NOFILES
		// ================ LineBuffer Initialization ===================

		/// <summary>
		///     Create and initialize a LineBuff buffer object for this scanner
		/// </summary>
		/// <param name="source">the list of input strings</param>
		public void SetSource(IList<string> source) {
			buffer = new LineBuff(source);
			chr = '\n'; // to initialize yyline, yycol and lineStart
			lNum = 0;
			cNum = -1;
			GetChr();
		}

		// =============== StreamBuffer Initialization ==================

		/// <summary>
		///     Create and initialize a StreamBuff buffer object for this scanner.
		///     StreamBuff is buffer for 8-bit byte files.
		/// </summary>
		/// <param name="source">the input byte stream</param>
		public void SetSource(Stream source) {
			buffer = new StreamBuff(source);
			lNum = 0;
			cNum = -1;
			chr = '\n'; // to initialize yyline, yycol and lineStart
			GetChr();
		}

#if !BYTEMODE
        // ================ TextBuffer Initialization ===================

        /// <summary>
        /// Create and initialize a TextBuff buffer object for this scanner.
        /// TextBuff is a buffer for encoded unicode files.
        /// </summary>
        /// <param name="source">the input text file</param>
        /// <param name="fallbackCodepage">Codepage to use if file has
        /// no BOM. For 0, use machine default; for -1, 8-bit binary</param>
        public void SetSource(Stream source, int fallbackCodepage)
        {
            this.buffer = TextBuff.NewTextBuff(source, fallbackCodepage);
            this.lNum = 0;
            this.cNum = -1;
            this.chr = '\n'; // to initialize yyline, yycol and lineStart
            GetChr();
        }
#endif // !BYTEMODE
#endif // !NOFILES

		// ==============================================================

#if BABEL
        //
        //  Get the next token for Visual Studio
        //
        //  "state" is the inout mode variable that maintains scanner
        //  state between calls, using the EolState property. In principle,
        //  if the calls of EolState are costly set could be called once
        //  only per line, at the start; and get called only at the end
        //  of the line. This needs more infrastructure ...
        //
        public int GetNext(ref int state, out int start, out int end)
        {
            Tokens next;
            int s, e;
            s = state;        // state at start
            EolState = state;
            next = (Tokens)Scan();
            state = EolState;
            e = state;       // state at end;
            start = tokPos;
            end = tokEPos - 1; // end is the index of last char.
            return (int)next;
        }
#endif // BABEL

		// ======== IScanner<> Implementation =========

		public override int yylex() {
			// parserMax is set by reflecting on the Tokens
			// enumeration.  If maxParseToken is defined
			// that is used, otherwise int.MaxValue is used.
			int next;
			do {
				next = Scan();
			} while (next >= parserMax);

			return next;
		}

		private int yyleng { get; set; }

		private int yypos { get; set; }

		private int yyline { get; set; }

		private int yycol { get; set; }

		public string yytext {
			get {
				if (tokTxt == null)
					tokTxt = buffer.GetString(yypos, tokEPos);
				return tokTxt;
			}
		}

		private void yyless(int n) {
			buffer.Pos = yypos;
			// Must read at least one char, so set before start.
			cNum = tokNum - 1;
			GetChr();
			// Now ensure that line counting is correct.
			lNum = yyline;
			// And count the rest of the text.
			for (var i = 0; i < n; i++) GetChr();
			MarkEnd();
		}

		// ============ methods available in actions ==============

		internal int YY_START {
			get => currentScOrd;
			set {
				currentScOrd = value;
				currentStart = startState[value];
			}
		}

		internal void BEGIN(int next) {
			currentScOrd = next;
			currentStart = startState[next];
		}

		// ============== The main tokenizer code =================

		private int Scan() {
			for (;;) {
				int next; // next state to enter                   
#if BACKUP
				var rslt = Result.noMatch;
#endif // BACKUP
#if LEFTANCHORS
                    for (;;)
                    {
                        // Discard characters that do not start any pattern.
                        // Must check the left anchor condition after *every* GetChr!
                        state = (lineStartNum == cNum ? anchorState[currentScOrd] : currentStart);
                        if ((next = NextState()) != goStart) 
                            break; // LOOP EXIT HERE...
                        GetChr();
                    }

#else // !LEFTANCHORS
				state = currentStart;
				while ((next = NextState()) == goStart)
					// At this point, the current character has no
					// transition from the current state.  We discard 
					// the "no-match" char.   In traditional LEX such 
					// characters are echoed to the console.
					GetChr();
#endif // LEFTANCHORS                    
				// At last, a valid transition ...    
				MarkToken();
				state = next;
				GetChr();

				while ((next = NextState()) > eofNum) // Exit for goStart AND for eofNum
#if BACKUP
					if (state <= maxAccept && next > maxAccept) // need to prepare backup data
					{
						// ctx is an object. The fields may be 
						// mutated by the call to Recurse2.
						// On return the data in ctx is the
						// *latest* accept state that was found.
						var ctx = new Context();
						rslt = Recurse2(ctx, next);
						if (rslt == Result.noMatch)
							RestoreStateAndPos(ctx);
						break;
					} else
#endif // BACKUP
					{
						state = next;
						GetChr();
					}

				if (state <= maxAccept) {
					MarkEnd();

					#region ActionSwitch

#pragma warning disable 162
					switch (state) {
						case eofNum:
							if (yywrap())
								return (int) Tokens.EOF;
							break;
						case 1:
						case 13:
							yylval.ival = int.Parse(yytext);
							return (int) Tokens.NUMBER;
							break;
						case 2:
							;
							break;
						case 3:
							;
							break;
						case 4:
							return (int) Tokens.MOD;
							break;
						case 5:
							return (int) Tokens.OPEN_PAREN;
							break;
						case 6:
							return (int) Tokens.CLOSE_PAREN;
							break;
						case 7:
							return (int) Tokens.MULT;
							break;
						case 8:
							return (int) Tokens.PLUS;
							break;
						case 9:
							return (int) Tokens.COMMA;
							break;
						case 10:
							return (int) Tokens.MINUS;
							break;
						case 11:
							return (int) Tokens.DOT;
							break;
						case 12:
							return (int) Tokens.DIV;
							break;
						case 14:
							return (int) Tokens.COLON;
							break;
						case 15:
							return (int) Tokens.SEMICOLON;
							break;
						case 16:
							return (int) Tokens.LESS;
							break;
						case 17:
							return (int) Tokens.EQUAL;
							break;
						case 18:
							return (int) Tokens.GREATER;
							break;
						case 19:
						case 22:
						case 23:
						case 24:
						case 25:
						case 26:
						case 27:
						case 28:
						case 29:
						case 30:
						case 31:
						case 32:
						case 33:
						case 36:
						case 38:
						case 39:
						case 40:
						case 42:
						case 44:
						case 45:
						case 46:
						case 47:
						case 49:
						case 51:
						case 53:
						case 54:
						case 55:
						case 56:
						case 57:
						case 58:
						case 60:
						case 61:
						case 62:
						case 63:
						case 64:
						case 65:
						case 67:
						case 68:
						case 72:
						case 73:
						case 78:
						case 79:
						case 80:
						case 81:
						case 83:
						case 84:
						case 86:
						case 87:
						case 89:
						case 90:
						case 92:
						case 94:
						case 95:
						case 96:
						case 97:
						case 98:
						case 100:
						case 101:
						case 102:
						case 103:
							yylval.sval = yytext;
							return (int) Tokens.IDENTIFIER;
							break;
						case 20:
							return (int) Tokens.LBRACKET;
							break;
						case 21:
							return (int) Tokens.RBRACKET;
							break;
						case 34:
							return (int) Tokens.LBRACE;
							break;
						case 35:
							return (int) Tokens.RBRACE;
							break;
						case 37:
							return (int) Tokens.XOR;
							break;
						case 41:
							return (int) Tokens.WHILE;
							break;
						case 43:
							return (int) Tokens.VAR;
							break;
						case 48:
							return (int) Tokens.TYPE;
							break;
						case 50:
							return (int) Tokens.TRUE;
							break;
						case 52:
							return (int) Tokens.THEN;
							break;
						case 59:
							return (int) Tokens.ROUTINE;
							break;
						case 66:
							return (int) Tokens.REVERSE;
							break;
						case 69:
							return (int) Tokens.RECORD;
							break;
						case 70:
							return (int) Tokens.REAL;
							break;
						case 71:
							return (int) Tokens.OR;
							break;
						case 74:
							return (int) Tokens.LOOP;
							break;
						case 75:
							return (int) Tokens.IF;
							break;
						case 76:
							return (int) Tokens.IN;
							break;
						case 77:
							return (int) Tokens.IS;
							break;
						case 82:
							return (int) Tokens.INT;
							break;
						case 85:
							return (int) Tokens.FOR;
							break;
						case 88:
							return (int) Tokens.FALSE;
							break;
						case 91:
							return (int) Tokens.END;
							break;
						case 93:
							return (int) Tokens.ELSE;
							break;
						case 99:
							return (int) Tokens.BOOLEAN;
							break;
						case 104:
							return (int) Tokens.ARRAY;
							break;
						case 105:
							return (int) Tokens.AND;
							break;
						case 106:
							return (int) Tokens.GREATEREQ;
							break;
						case 107:
							return (int) Tokens.LESSEQ;
							break;
						case 108:
							return (int) Tokens.ASSIGN;
							break;
						case 109:
							yylval.dval = double.Parse(yytext);
							return (int) Tokens.REALNUM;
							break;
						case 110:
							return (int) Tokens.NOT_EQUAL;
							break;
						case 111:
							return (int) Tokens.RANGE;
							break;
						case 112:
							return 0;
							break;
					}
#pragma warning restore 162

					#endregion
				}
			}
		}

#if BACKUP
		private Result Recurse2(Context ctx, int next) {
			// Assert: at entry "state" is an accept state AND
			//         NextState(state, chr) != goStart AND
			//         NextState(state, chr) is not an accept state.
			//
			SaveStateAndPos(ctx);
			state = next;
			// if (state == eofNum) return Result.accept;
			GetChr();

			while ((next = NextState()) > eofNum) {
				if (state <= maxAccept && next > maxAccept) // need to update backup data
					SaveStateAndPos(ctx);
				state = next;
				if (state == eofNum) return Result.accept;
				GetChr();
			}

			return state <= maxAccept ? Result.accept : Result.noMatch;
		}

		private void SaveStateAndPos(Context ctx) {
			ctx.bPos = buffer.Pos;
			ctx.cNum = cNum;
			ctx.lNum = lNum;
			ctx.state = state;
			ctx.cChr = chr;
		}

		private void RestoreStateAndPos(Context ctx) {
			buffer.Pos = ctx.bPos;
			cNum = ctx.cNum;
			lNum = ctx.lNum;
			state = ctx.state;
			chr = ctx.cChr;
		}

		private void RestorePos(Context ctx) {
			buffer.Pos = ctx.bPos;
			cNum = ctx.cNum;
		}
#endif // BACKUP

		// ============= End of the tokenizer code ================

#if STACK
		internal void yy_clear_stack() {
			scStack.Clear();
		}

		internal int yy_top_state() {
			return scStack.Peek();
		}

		internal void yy_push_state(int state) {
			scStack.Push(currentScOrd);
			BEGIN(state);
		}

		internal void yy_pop_state() {
			// Protect against input errors that pop too far ...
			if (scStack.Count > 0) {
				var newSc = scStack.Pop();
				BEGIN(newSc);
			} // Otherwise leave stack unchanged.
		}
#endif // STACK

		internal void ECHO() {
			Console.Out.Write(yytext);
		}
	} // end class Scanner
} // end namespace